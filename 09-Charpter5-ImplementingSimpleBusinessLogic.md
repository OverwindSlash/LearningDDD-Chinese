## 第 5 章
# 实现简单业务逻辑

业务逻辑是软件中最重要的部分。它是软件被实现的首要原因。一个系统的用户界面可以是性感的，它的数据库也可以是快速和可扩展的。但是，如果该软件对业务没有用处，它只不过是一个昂贵的技术演示品而已。

正如我们在第 2 章看到的，并非所有的业务子域都是平等的。不同的子域有不同程度的战略重要性和复杂性。本章开始我们对建模和实现业务逻辑的代码以不同的方式进行探索。我们将从适合简单业务逻辑的两种模式开始：事务脚本和活动记录。

## 事务脚本

> 按过程组织业务逻辑，其中每个过程处理来自表现层的单个请求。 <br>
> —Martin Fowler [^1]

一个系统的公开接口可以被看作是消费者能够执行的业务事务的集合，如图5-1所示。这些事务可以检索由系统管理的信息，也可以修改信息，或者两者兼而有之。该模式以过程为基础组织系统的业务逻辑，每个过程实现一个操作，由系统的消费者通过系统的公开接口执行。实际上，系统的公开操作被用作封装的边界。

<img src=images/figure5-1.png />
图 5-1. 事务脚本接口 <br><br>

### 实现
每个过程都被实现为一个简单明了的程序脚本。它可以使用一个薄的抽象层来与存储机制集成，也可以自由地直接访问数据库。

过程必须满足的唯一要求是事务行为。*每个操作要么成功，要么失败，但不能导致无效的状态*。即使事务脚本的执行在最麻烦的时刻失败了，系统也应该保持一致 -- 要么通过回滚它所做的更改直到失败，要么执行补偿性操作。事务行为反映在该模式的名称中：事务脚本。

下面是一个事务脚本的例子，它将一批 JSON 文件转换为 XML 文件。

```cs
DB.StartTransaction();

var job = DB.LoadNextJob();
var json = LoadFile(job.Source);
var xml = ConvertJsonToXml(json);
WriteFile(job.Destination, xml.ToString());
DB.MarkJobAsCompleted(job);

DB.Commit();
```

### 没那么简单
当我在领域驱动设计课上介绍事务脚本模式时，学生们常常扬起眉毛，有些人甚至会问："这值得我们花时间吗？我们不是来学习更高级的模式和技术的吗？"

问题在于，事务脚本模式是你在随后章节中将学习到的更高级别业务逻辑实现模式的 *基础*。此外，尽管它表面上很简单，但它是最容易出错的模式。我曾以这样或那样的方式帮助调试和修正过相当数量的生产问题，往往都归结为对系统业务逻辑中事务行为的错误实现。

让我们来看看三个常见的、现实生活中的例子，它们由于未能正确执行事务脚本而导致了数据的损坏。

#### 缺乏事务行为
未能实现事务行为的一个简单的例子是：在没有总体事务的情况下发布多个更新。考虑以下方法，更新 Users 表中的一条记录，并向 VisitsLog 表中插入一条记录。

```cs
 1 public class LogVisit
 2 {
 3     // ...
 4 
 5     public void Execute(Guid userId, DataTime visitedOn)
 6     {
 7         _db.Execute(“UPDATE Users SET last_visit=@p1 WHERE user_id=@p2”,
 8                     visitedOn, userId);
 9         _db.Execute(@“INSERT INTO VisitsLog(user_id, visit_date)
10                     VALUES(@p1, @p2)”, userId, visitedOn);
11     }
12 } 
```

如果在 Users 表中的记录被更新后（第 7 行），但在第 9 行的日志记录追加成功之前发生任何问题，系统将最终处于不一致的状态。Users 表虽然被更新，但没有对应的记录被写入 VisitsLog 表。这个问题可能是由于网络中断、数据库超时或死锁、甚至是执行该进程的服务器崩溃造成的。

这可以通过引入一个包含两个数据变更的适当事务来解决。

```cs
public class LogVisit
{
    // ...

    public void Execute(Guid userId, DataTime visitedOn)
    {
        try
        {
            _db.StartTransaction();

            _db.Execute(@“UPDATE Users SET last_visit=@p1 WHERE user_id=@p2”,
                       visitedOn, userId);

            _db.Execute(@“INSERT INTO VisitsLog(user_id, visit_date)
                       VALUES(@p1, @p2)”, userId, visitedOn);

            _db.Commit();
        } catch {
            _db.Rollback();
            throw;
        }
    }
}
```

#### 分布式事务
在现代分布式系统中，对数据库中的数据进行修改，然后通过向消息总线发布消息来通知系统中的其他组件，是一种常见的做法。考虑到在前面的例子中，我们需要将访问信息发布到消息总线，而不是在数据库表中记录它：

```cs
 1 public class LogVisit
 2 {
 3     // ...
 4 
 5     public void Execute(Guid userId, DataTime visitedOn)
 6     {
 7         _db.Execute(“UPDATE Users SET last_visit=@p1 WHERE user_id=@p2”,
 8                     visitedOn,userId);
 9         _messageBus.Publish(“VISITS_TOPIC”,
10                             new { UserId = userId, VisitDate = visitedOn });
11     }
12 } 
```

和前面的例子一样，任何发生在第7行之后但在第9行成功之前的故障都会破坏系统的状态。用户表将被更新，但其他组件无法被通知，因为向消息总线发布信息失败了。

不幸的是，解决这个问题并不像前面的例子那样容易。跨越多个存储机制的分布式事务很复杂，难以扩展，容易出错，因此通常会被避免。在第 8 章中，你将学习如何使用 CQRS 架构模式来填充多种存储机制。此外，第 9 章将介绍发件箱（outbox）模式，它能在将变更提交到数据库后可靠地发布消息。

让我们看一个更复杂的事务行为不当实现的例子。

#### 隐式分布式事务
考虑以下看似简单的方法：

```cs
public class LogVisit
{
    // ...
 
    public void Execute(Guid userId)
    {
        _db.Execute(“UPDATE Users SET visits=visits+1 WHERE user_id=@p1”,
                    userId);
    }
}
```

这个方法没有像前面的例子那样跟踪最后的访问日期，而是为每个用户维护一个访问计数器。调用该方法会使相应的计数器的值增加1。该方法所做的只是在数据库的一个表中更新一个值。然而，这仍然是一个分布式事务，有可能导致不一致的状态。

这个例子形成了一个分布式事务，因为它向数据库以及调用该方法的外部进程传递了信息，如图5-2所示。

<img src=images/figure5-2.png />
图 5-2. LogVisit 操作更新数据并通知调用者操作成功与否 <br><br>

尽管 Execute 方法是 void 类型的，也就是说，它不返回任何数据，但它仍然传达了操作是成功还是失败的信息：如果失败了，调用者会得到一个异常。如果方法执行成功了，但与调用者的结果交流却失败了呢？比如说：

* 如果 LogVisit 是 REST 服务的一部分，并且出现了网络中断；或
* 如果 LogVisit 和调用者都在同一进程中运行，但在调用者跟踪 LogVisit 动作的成功执行之前，该进程已经失败了？

（译注：其实以上两种情况都是调用者未能收到 3.Result 的相关信息）

在这两种情况下，消费者将假设调用失败，并尝试再次调用 LogVisit。再次执行 LogVisit 逻辑将导致计数器值错误地增加。总的来说，它将增加 2 而不是 1。正如前两个例子一样，代码未能正确实现事务脚本模式，并无意中破坏了系统状态。

与前面的示例一样，此问题没有简单的解决方法。这完全取决于业务领域及其需求。在这个特定示例中，确保事务行为正确的一种方法是使操作具有 *幂等性*：哪怕操作被重复多次也会有相同的结果。

例如，我们可以要求消费者传递计数器的值。为了提供计数器的值，调用者必须先读取当前值，在本地增加它，然后提供更新的值作为参数。即使这个操作会被执行多次，也不会改变最终的结果。（译注：但是会产生后更新的值覆盖之前更新的值的情况，哪怕在业务上，之前更新的值更后产生）

```cs
public class LogVisit
{
    // ...
    
    public void Execute(Guid userId, long visits)
    {
        _db.Execute(“UPDATE Users SET visits = @p1 WHERE user_id=@p2”,
                   visits, userId);
    }
}
```

解决此类问题的另一种方法是使用乐观并发控制：在调用 LogVisit 操作之前，调用者已读取计数器的当前值并将其作为参数传递给 LogVisit。只有当代码执行时数据库中的值等于调用者最初读取的值时，LogVisit 才会更新计数器：

```cs
public class LogVisit
{
    // ...

    public void Execute(Guid userId, long expectedVisits)
    {
        _db.Execute(@“UPDATE Users SET visits=visits+1
                      WHERE user_id=@p1 and visits = @p2”,
                      userId, visits);
    }
}
```

具有相同参数的后续 LogVisit 执行不会更改数据，因为 WHERE...visits = @p2 条件不会被满足。

### 何时使用事务脚本
事务脚本模式很适合于最直接的问题领域，其中的业务逻辑类似于简单的过程性操作。例如，在提取-转换-加载（ETL）操作中，每个操作都从源头提取数据，应用转换逻辑将其转换成另一种形式，并将结果加载到目标存储中。这个过程如图5-3所示。

<img src=images/figure5-3.png />
图 5-3. 提取-转换-加载数据流 <br><br>

事务脚本模式天然适合支撑子域，根据定义，支撑子域的业务逻辑很简单。事务脚本也可以被用作与外部系统集成的适配器 -- 例如，通用子域，或作为防腐层的一部分（在第 9 章会有更多介绍）。

事务脚本模式的主要优点是它的简单性。它引入了最少的抽象，并最大限度地减少了运行时的性能开销和理解业务逻辑方面的成本。尽管如此，这种简单性也是该模式的缺点。业务逻辑越复杂，就越容易在不同的事务中重复业务逻辑，当重复的代码不同步时，就会导致不一致的行为。因此，事务脚本不应该被用于核心子域，因为这种模式无法应对核心子域业务逻辑的高度复杂性。

这种简单性为事务脚本换取了一个不太可靠的口碑。有时，事务脚本甚至会被当作一种反模式。毕竟，如果复杂的业务逻辑以事务脚本的形式实现，迟早会变成一个无法维护的大泥球。然而，值得注意的是，尽管事务脚本模式很简单，但它在软件开发中却无处不在。我们在本章和后续章节中讨论的所有业务逻辑的实现模式，都会或多或少的基于事务脚本模式。

## 活动记录

> 一个包装了数据库表或视图中一行数据的对象、此对象封装数据库访问并在封装的数据上添加领域逻辑。<br>
> — Martin Fowler [^2]

像事务脚本模式一样，活动记录支持简单业务逻辑的情况。然而，业务逻辑可以实现在更复杂的数据结构上。例如，我们可以有更复杂的对象树和层次结构，而不是平面记录，如图5-4所示。

<img src=images/figure5-4.png />
图 5-4. 具有一对多和多对多关系的更复杂的数据模型 <br><br>

通过简单的事务脚本对此类数据结构进行操作会导致大量重复代码。到处都是从数据到内存展示对象（in-memory representation）的重复映射。

### 实现
因此，此模式使用称为活动记录的专用对象来表示复杂的数据结构。除了数据结构之外，这些对象还实现了用于创建、读取、更新和删除记录的数据访问方法 -- 即所谓的 CRUD 操作。结果，活动记录对象会被耦合到对象关系映射 (ORM) 或一些其他数据访问框架。模式的名称来源于每个数据结构都是“活动的”这一事实；也就是说，它实现了数据访问逻辑。

与前述模式一样，系统的业务逻辑被组织在一个过程脚本中。两种模式的区别在于，在这种情况下，过程脚本不是直接访问数据库，而是操作活动记录对象。完成后，操作必须作为原子事务完成或失败：

```cs
public class CreateUser
{
    // ...

    public void Execute(userDetails)
    {
        try
        {
            _db.StartTransaction();

            var user = new User();
            user.Name = userDetails.Name;
            user.Email = userDetails.Email;
            user.Save();

            _db.Commit();
        } catch {
            _db.Rollback();
            throw;
        }
    }
}
```

该模式的目标是封装复杂性，即将内存中的对象映射到数据库结构（schema）的复杂性。除了负责持久化，活动记录对象还可以包含业务逻辑；例如，验证分配给字段的新值，甚至实现操作对象数据的相关业务过程。也就是说，活动记录对象的显著特征是数据结构和行为（业务逻辑）的分离（译注：这里原文在说明行为时只提到了业务逻辑，没有提及 CRUD 逻辑，这是因为活动记录对象本身的固有问题就是耦合进了 CRUD 逻辑，这个问题将会被领域模型模式所解决）。通常情况下，活动记录的字段有公共的 getters 和 setters，允许外部程序修改其状态。

### 何时使用活动记录
因为活动记录本质上是一个优化访问数据库的事务脚本，所以这种模式只能支持比较简单的业务逻辑，比如 CRUD 操作，最多进行用户输入的验证。

因此，就像事务脚本模式一样，活动记录模式适合于支撑子域，或整合通用子域的外部解决方案，以及模型转换任务。这些模式之间的区别在于，活动记录解决了将复杂的数据结构映射到数据库结构的复杂性。

活动记录模式也被称为 *贫血领域模型反模式*；换句话说，是一个设计不当的领域模型。我更愿意克制对于 *贫血* 和 *反模式* 这两个词负面含义的理解。活动记录模式是一种工具。像任何工具一样，它可以解决问题，但如果应用在错误的环境中，也可能会弊大于利。在业务逻辑简单时，使用活动记录并无不妥。此外，在实现简单的业务逻辑时使用更复杂的模式，也会因引入意外的复杂性而造成危害。在下一章中，你将学习什么是领域模型，以及它与活动记录模式有什么不同。

&emsp;&emsp;<img src=images/general-note.png width=50 />&emsp;&emsp;需要强调的是，在这里，*活动记录* 指的是设计模式，而不是活动记录框架。该模式的名称是由 Martin Fowler 在《*企业应用架构模式*》中创造的。框架则是后来才出现的，是该模式的一种实现方式。在我们的上下文中，我们谈论的是设计模式和它背后的概念，而不是具体的框架实现。

## 保持务实
虽然业务数据很重要，我们设计和构建的代码应该保护其完整性，但在有些情况下，务实的方法更可取。

尤其是在高规模（high levels of scale）时，有些情况下可以放宽对数据的一致性保证。需要确认在 100 万条记录中有一条损坏的情况是否真的会给企业带来麻烦，是否会对企业的性能和盈利能力产生负面影响。例如，假设你正在构建一个系统，该系统每天从 IoT 设备接收数十亿个事件。如果 0.001% 的事件会重复或丢失，这有什么大不了的吗？

与往常一样，没有放之四海而皆准的规则。这一切都取决于你所从事的业务领域。尽可能的“偷工减料”是可以的；只需确保你评估了风险和对业务影响即可。

## 结论

在本章中，我们介绍了两种实现业务逻辑的模式：

*事务脚本*

这种模式将系统的操作组织为简单、直接的过程脚本。这些过程确保每个操作都是事务性的 -- 要么成功，要么失败。事务脚本模式适合于支撑子域，其业务逻辑类似于简单的、像 ETL 那样的操作。

*活动记录*

当业务逻辑很简单但需要对复杂的数据结构进行操作时，你可以将这些数据结构实现为活动记录。活动记录对象是一个提供简单 CRUD 数据访问方法的数据结构。

本章讨论的两种模式是面向相对简单的业务逻辑的方案。在下一章，我们将转向更复杂的业务逻辑，并讨论如何使用领域模型模式来解决复杂问题。

## 练习
1. 在实现核心子域的业务逻辑时，应该使用哪种讨论过的模式？<br>
A. 事务脚本 <br>
B. 活动记录 <br>
C. 这两种模式都不能用来实现核心子域。 <br>
D. 两者都可以用来实现核心子域。 <br>

2. 考虑以下代码：
	
	```cs
	public void CreateTicket(TicketData data)
	{
	    var agent = FindLeastBusyAgent();

	    agent.ActiveTickets = agent.ActiveTickets + 1;
	    agent.Save();

	    var ticket = new Ticket();
	    ticket.Id = Guid.New();
	    ticket.Data = data;
	    ticket.AssignedAgent = agent;
	    ticket.Save();
        
	    _alerts.Send(agent, “You have a new ticket!”);
	}
	```
	
	假设没有高级事务管理机制，你可以在这里发现哪些潜在的数据一致性问题？<br>
A. 收到新工单后，指定专员的有效工单计数可能增加 1 以上。 <br>
B. 专员的活动工单计数会增加 1，但不会为专员分配任何新工单。 <br>
C. 专员会得到一张新的工单，但不会收到有关通知。 <br>
D. 所有以上的问题都有可能发生。 <br>

3. 在前面的代码中，至少还有一种可能会破坏系统状态的极端情况。你能发现吗？

4. 回到本书序言中 WolfDesk 的例子，系统的哪些部分有可能被实现为事务脚本或活动记录？


[^1]: Fowler, M. (2002). 企业应用架构模式。波士顿。Addison-Wesley
[^2]: Fowler, M. (2002). 企业应用架构模式。波士顿。Addison-Wesley
