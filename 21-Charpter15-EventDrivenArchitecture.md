## 第 15 章
# 事件驱动架构

与微服务类似，事件驱动架构（EDA）在现代分布式系统中是无处不在的。许多人建议在设计松散耦合、可扩展、容错的分布式系统时，使用事件驱动的通信作为默认的集成机制。

事件驱动架构经常与领域驱动设计相联系。毕竟，EDA 是基于事件的，而事件在 DDD 中也很突出--我们有领域事件，在需要的时候，我们甚至把事件作为系统的真相来源。利用 DDD 的事件作为使用事件驱动架构的基础，可能是很诱人的。但这是个好主意吗？

事件并不是一种秘制酱料，你可以把它倒在一个传统的系统上，让它变成松散耦合的分布式系统。恰恰相反：EDA 的粗心使用可能会把一个模块化的单体变成一个分布式大泥球。

在本章中，我们将探讨 EDA 和 DDD 之间的相互作用。你将学习事件驱动架构的基本构件，EDA 项目失败的常见原因，以及你如何利用 DDD 的工具来设计有效的、异步集成的系统。

## 事件驱动架构

简单地说，事件驱动架构是一种架构风格，系统的组件通过交互事件消息进行异步通信（见图15-1）。与同步调用服务的端点不同，组件通过发布事件来通知系统的其他元素关于组建在系统领域中的变化。组件可以订阅系统中发生的事件并做出相应的反应。事件驱动执行流程的一个典型例子是第 9 章中描述的 saga 模式。

<img src=images/figure15-1.png />
图 15-1. 异步通信 <br><br>

强调事件驱动架构和事件溯源之间的区别很重要。正如我们在第 7 章所讨论的，事件溯源是一种将状态的变化作为一系列事件来捕获的方法。

尽管事件驱动架构和事件溯源都是基于事件的，但这两种模式在概念上是不同的。EDA 指的是服务之间的通信，而事件溯源发生在服务内部。为事件溯源设计的事件代表了服务中实现的状态转换（事件溯源领域模型中的聚合）。它们的目的是捕捉业务领域的复杂性，而不是为了将服务与其它系统组件集成。

正如你在本章后面将看到的，有三种类型的事件，有些比其他的更适合于整合。

## 事件

在 EDA 系统中，事件的交互是整合各组件并使其成为一个系统的关键通信机制。让我们更详细地了解一下事件，看看它们与消息有什么不同。

### 事件，命令和消息

到目前为止，事件的定义与消息模式的定义相似。[^1] 然而，这两者是不同的。事件是一个消息，但消息并不一定是一个事件。有两种类型的消息。

*事件*

一种用于描述已经发生了的变化的消息

*命令*

一种用于描述需要被执行的操作的消息

事件是已经发生的事情，而命令是做某事的指令。事件和命令都能以消息进行异步通信。然而，一个命令可以被拒绝：命令的目标可以拒绝执行该命令，例如，如果该命令是无效的或与系统的业务规则相违背。另一方面，一个事件的接收者不能取消该事件。事件描述的是已经发生的事情。要推翻一个事件，唯一能做的就是发布一个补偿性的行动--命令，就像在 saga 模式中执行的那样。

由于事件描述的是已经发生的事情，事件的名称应该用过去式来表述：例如，DeliveryScheduled，ShipmentCompleted，或 DeliveryConfirmed。

## 结构

一个事件是一个数据记录，它可以被序列化并使用所选择的信息传递平台进行传输。一个典型的事件结构（schema）包括事件的元数据和它的荷载--事件所传达的信息。

```json
{
    "type": "delivery-confirmed",
    "event-id": "14101928-4d79-4da6-9486-dbc4837bc612",
    "correlation-id": "08011958-6066-4815-8dbe-dee6d9e5ebac",
    "delivery-id": "05011927-a328-4860-a106-737b2929db4e",
    "timestamp": 1615718833,
    "payload": {
        "confirmed-by": "17bc9223-bdd6-4382-954d-f1410fd286bd",
        "delivery-time": 1615701406
    }
}
```

一个事件的有效载荷不仅描述了事件所传达的信息，而且还定义了事件的类型。让我们详细讨论这三种类型的事件，以及它们之间的区别。

### 事件类型

事件可分为三种类型 [^2]：事件通知、事件携带状态转移或领域事件。

#### 事件通知

事件通知是一个关于业务领域变化的消息，其他组件将对此作出反应。例子包括 PaycheckGenerated 和 CampaignPublished，等等。

通知事件不应该是冗长的：目的是将事件通知给有关各方，但通知不应该携带订阅者对事件做出反应所需的所有信息。比如说。

```json
{
    "type": "paycheck-generated",
    "event-id": "537ec7c2-d1a1-2005-8654-96aee1116b72",
    "delivery-id": "05011927-a328-4860-a106-737b2929db4e",
    "timestamp": 1615726445,
    "payload": {
        "employee-id": "456123",
        "link": "/paychecks/456123/2021/01"
    }
}
```

在前面的代码中，该事件通知了外部组件已经生成了一份工资单。它并没有携带与工资单有关的所有信息。相反，接收者可以使用链接来获取更详细的信息。这个通知流程如图 15-2 所示。

<img src=images/figure15-2.png />
图 15-2. 事件通知流程 <br><br>

从某种意义上，整合通知事件的信息类似于美国的无线紧急警报（WEA）系统和欧洲的 EU-Alert（见图15-3）。这些系统使用手机信号塔来广播短消息，通知市民有关公共卫生问题、安全威胁和其他紧急情况。这些系统只限于发送最长为 360 个字符的信息。这种短信息足以通知你紧急情况，但你必须积极主动地使用其他信息来源来获得更多细节。

<img src=images/figure15-3.png />
图 15-3. 紧急警报系统 <br><br>

在许多情况下，简洁的事件通知是比较好的。让我们仔细看看两个场景：安全和并发性。

**安全性**。强制要求收件人明确查询详细信息，可以防止通过信息传递基础设施共享敏感信息，并要求用户通过获得额外的授权来访问数据。

**并发性**。由于事件驱动集成的异步性，当信息到达订阅者时，它可能已经过时了。如果信息的性质对竞争条件很敏感，明确地查询它可以获得其最新的状态。

而且，在并发消费的场合，如果只有一个订阅者可以处理事件，事件的查询过程可以通过使用悲观锁而被集成。这可以保证在消费侧，没有其他的消费者能处理到这个消息。

#### 事件携带状态转移

事件携带状态转移（ECST）消息通知订阅者关于生产者内部状态的变化。与事件通知消息相反，ECST 消息包括反映状态变化的所有数据。

ECST 消息可以有两种形式。第一种是被修改的实体的状态的完整快照。

```json
{
    "type": "customer-updated",
    "event-id": "6b7ce6c6-8587-4e4f-924a-cec028000ce6",
    "customer-id": "01b18d56-b79a-4873-ac99-3d9f767dbe61",
    "timestamp": 1615728520,
    "payload": {
        "first-name": "Carolyn",
        "last-name": "Hayes",
        "phone": "555-1022",
        "status": "follow-up-set",
        "follow-up-date": "2021/05/08",
        "birthday": "1982/04/05",
        "version": 7
    }
}
```

前面例子中的 ECST 消息包括一个客户更新状态的完整快照。当操作大型数据结构时，在 ECST 消息中只包括实际被修改的字段可能是合理的。

```json
{
    "type": "customer-updated",
    "event-id": "6b7ce6c6-8587-4e4f-924a-cec028000ce6",
    "customer-id": "01b18d56-b79a-4873-ac99-3d9f767dbe61",
    "timestamp": 1615728520,
    "payload": {
        "status": "follow-up-set",
        "follow-up-date": "2021/05/10",
        "version": 8
    }
}
```

无论ECST消息包括完整的快照还是只包括更新的字段，这样的事件流允许消费者持有实体状态的本地缓存并可以使用它。从概念上讲，使用事件携带状态转移消息是一种异步的数据复制机制。这种方法使系统更具容错性，意味着即便生产者不可用，消费者也能继续运作。这也是提高组件性能的一种方法，此组件需要处理来自多个来源的数据。因为所有的数据都可以在本地缓存，而不是在每次需要数据时去查询数据源，如图15-4所示。

<img src=images/figure15-4.png />
图 15-4. 为前端服务的后端 <br><br>

#### 领域事件

第三种类型的事件消息是我们在第 6 章中描述的领域事件。某种程度上，领域事件介于事件通知和 ECST 消息之间：它们都描述了业务领域中的一个重要事件，并且它们包含描述该事件的所有数据。尽管有相似之处，这些类型的消息在概念上是不同的。

#### 领域事件 VS 事件通知

领域事件和事件通知都描述了生产者业务领域的变化。从另一个角度说，有两个概念上的区别。

首先，领域事件包括描述该事件的所有信息。消费者不需要采取任何进一步的行动来获得完整的信息。

其次，建模意图是不同的。事件通知的设计目的是为了减轻与其他组件的整合。相对的，领域事件的目的是对业务领域进行建模和描述。即使没有外部消费者对其感兴趣，领域事件也是有用的。这在事件溯源系统中尤其如此，领域事件被用来模拟所有可能的状态转换。让外部消费者对所有可用的领域事件都感兴趣会导致不太理想的设计。我们将在本章后面更详细地讨论这个问题。

#### 领域事件 VS 事件携带状态转移

领域事件中包含的数据在概念上与典型的 ECST 消息的模式不同。

一个 ECST 消息提供了足够的信息来保持生产者数据的本地缓存。没有一个领域事件应该暴露出如此丰富的模型。即使是包含在特定领域事件中的数据也不足以缓存聚合的状态，因为消费者未订阅的其他领域事件可能会影响相同的字段。

此外，与事件通知的情况一样，这两类消息的建模意图是不同的。包含在领域事件中的数据并不是为了描述聚合的状态。相反，它描述了在其生命周期内发生的业务事件。

#### 事件类型：示例

这里有一个例子可以展示这三种类型的事件之间的区别。考虑用以下三种方式来表示结婚这一事件。

```js
eventNotification = {
    "type": "marriage-recorded",
    "person-id": "01b9a761",
    "payload": {
        "person-id": "126a7b61",
        "details": "/01b9a761/marriage-data"
    }
};

ecst = {
    "type": "personal-details-changed",
    "person-id": "01b9a761",
    "payload": {
        "new-last-name": "Williams"
    }
};

domainEvent = {
    "type": "married",
    "person-id": "01b9a761",
    "payload": {
        "person-id": "126a7b61",
        "assumed-partner-last-name": true
    }
};
```
marriage-recorded 是一个事件通知消息。它不包含任何信息，除了具有指定 ID 的人结婚的事实。它包含关于该事件的最低限度的信息，对更多细节感兴趣的消费者将不得不访问细节字段中的链接。

personal-details-changed 是一个事件携带状态转移消息。它描述了此人个人资料的变化，即他们的姓氏已经被改变。该消息没有解释改变的原因。这个人是结婚了还是离婚了？(译注：主要目的就是在本地缓存聚合的最新状态)

最后，married 是一个领域事件。它的模型尽可能地接近业务领域中事件的性质。它包括这个人的 ID 和一个标志，表明这个人是沿用了他们伴侣的名字。

## 设计事件驱动集成

正如我们在第 3 章所讨论的，软件设计主要是关于边界的。边界界定了什么属于内部，什么留在外部，以及最重要的是，什么会跨越边界 -- 本质上就是，组件是如何相互集成的。基于EDA 的系统中，事件是最高优先级的设计元素，它既会影响组件的集成方式，也会影响组件的边界本身。选择正确的事件信息类型是成就（解耦）或破坏（耦合）一个分布式系统的关键。

在本节中，你将学习应用不同事件类型的启发式方法。但首先，让我们看看如何使用事件来设计一个强耦合、分布式的大泥球。

### 分布式大泥球

考虑图 15-5 所示的系统。

CRM 的限界上下文是作为一个事件溯源领域模型来实现的。当 CRM 系统必须与 Marketing 上下文集成时，团队决定利用事件溯源数据模型的灵活性，让消费者（在本例中为 Marketing 上下文）订阅 CRM 的领域事件，并使用它们来投影出适合他们需求的模型。

当 AdsOptimization 的限界上下文被引入时，它也必须处理 CRM 限界上下文所产生的信息。同样，这些团队决定让 AdsOptimization 订阅 CRM 中产生的所有领域事件，并投影出适合 AdsOptimization 需求的模型。

<img src=images/figure15-5.png />
图 15-5. 为前端服务的后端 <br><br>

有趣的是，Marketing 和 AdsOptimization 限界上下文都必须以相同的格式呈现客户的信息，因此最终从 CRM 的领域事件中投影了相同的模型：每个客户状态的扁平化快照。

Reporting 限界上下文只订阅了 CRM 发布的领域事件的一个子集，并使用事件通知消息来获取 AdsOptimization 上下文中执行的计算结果。然而，由于 Reporting 限界上下文和 AdsOptimization 限界上下文都使用相同的事件来触发它们的计算，为了确保 Reporting 上下文的模型能被正确更新，Reporting 上下文引入了一个延迟。它在收到消息 5 分钟后才处理。

这种设计很糟糕。我们来分析一下这个系统中的耦合类型。

### 时间性耦合

AdsOptimization 和 Reporting 限界上下文形成了时间上的耦合：它们依赖于严格的执行顺序。AdsOptimization 组件必须在 Reporting 模块被触发之前完成其处理。如果顺序颠倒了，在 Reporting 系统中就会产生不一致的数据。

为了保证所需的执行顺序，工程师们在 Reporting 系统中引入了处理延迟。这个 5 分钟的延迟让 AdsOptimization 组件完成了所需的计算。显然，这并不能防止不正确的执行顺序：

* AdsOptimization 可能处于高负载，无法在 5 分钟内完成处理。
* 网络问题可能会延迟向 AdsOptimization 服务发送传入的信息。
* AdsOptimization 组件可能出现故障并停止处理传入的信息。

### 功能性耦合

Marketing 和 AdsOptimization 的限界上下文都订阅了 CRM 的领域事件，并最终实现了对客户数据的相同投影。换句话说，将传入的领域事件转化为基于状态表示的业务逻辑在两个限界上下文中都是重复的，而且它有相同的变化原因：它们必须以相同的格式呈现客户的数据。因此，如果投影在其中一个组件中被改变，这种改变必须在第二个限界上下文中被复制。

这就是功能性耦合的一个例子：多个组件实现相同的业务功能，如果它发生变化，多个组件必须同时改变。

### 实现细节耦合

这种类型的耦合是比较微妙的。Marketing 和 AdsOptimization 限界上下文订阅了所有由 CRM 的事件溯源模型产生的领域事件。因此，CRM 实现中的变化，如添加一个新的领域事件或改变现有事件的结构，就必须反映在两个订阅的限界上下文中！如果不这样做，会导致数据不一致。例如，如果一个事件的结构改变了，订阅者的投影逻辑就会失败。另一方面，如果一个新的领域事件被添加到 CRM 的模型中，它可能会影响到投影模型，因此，忽略它将导致投影出不一致的状态。

### 重构事件驱动集成

正如你所看到的，盲目地把事件倾倒在系统上，会让系统既不能解耦，也没有弹性。你可能会认为刚刚说的不是现实的例子，但不幸的是，这个例子基于一个真实的故事。让我们来看看如何调整事件来大大改善设计。

暴露构成 CRM 数据模型的所有领域事件，会使订阅者与生产者的实现细节产生耦合。实现细节耦合可以通过暴露更严格的事件集或不同类型的事件来解决。

Marketing 和 AdsOptimization 订阅者由于实现相同的业务功能而导致功能耦合。

实现和功能耦合都可以通过封装生产者（CRM 限界上下文）的投影逻辑来解决。与其暴露其实现细节，CRM 可以遵循消费者驱动合约模式：投影消费者所需的模型，并使其成为限界上下文中发布语言的一部分--一个与内部实现模型解耦的集成专用模型。因此，消费者可以得到他们需要的所有数据，而不需要知道 CRM 的实现模型。

为了解决 AdsOptimization 和 Reporting 限界上下文之间的时间耦合问题，AdsOptimization 组件可以发布一个事件通知信息，触发 Reporting 组件获取它所需要的数据。这个重构的系统如图 15-6 所示。

<img src=images/figure15-6.png />
图 15-6. 重构后的系统 <br><br>

### 事件驱动设计启发式方法

将事件的类型与手头的任务相匹配，使得所产生的设计在规模上更少的耦合，更灵活，并且容错。让我们来制定应对变化背后的设计启发式方法。

#### 假设最坏的情况

正如 Andrew Grove 所说，只有偏执狂才能生存 [^3]。在设计事件驱动的系统时，请将此作为一个指导原则。

* 网络可能会很慢。
* 服务器可能在最麻烦的时刻出现故障。
* 事件可能无序到达。
* 事件可能重复。

最重要的是，这些问题将在周末和法定节假日最频繁地发生。

事件驱动架构中的 *驱动* 一词意味着你的整个系统取决于信息的成功传递。因此，要像避免瘟疫一样避免 "事情会好起来" 的心态。无论如何，要确保事件始终如一地被交付：

* 使用发件箱模式可靠地发布消息。
* 发布消息时，确保订阅者能够进行重复消息删除并识别和重排乱序消息。
* 在编排需要发布补偿操作的跨限界上下文流程时，利用 saga 和流程管理器模式。

#### 使用公开事件和私有事件

在发布领域事件时要警惕暴露实现细节，特别是在事件溯源聚合中。将事件视为限界上下文公开接口的固有部分。因此，在实现开放主机服务模式时，要确保事件反映在限界上下文的发布语言中。第 9 章中已讨论了基于事件模型的转换模式。

在设计限界上下文的公开接口时，要利用不同类型的事件。事件携带状态转移消息将实现模型压缩成一个更紧凑的模型，只传达消费者需要的信息。

事件通知信息可用于进一步减少公开接口。

最后，谨慎使用领域事件与外部限界上下文进行通信。考虑设计一组专用的公共领域事件。

#### 评估一致性需求

在设计事件驱动的通信时，评估限界上下文的一致性需求，以此作为选择事件类型的额外启发式方法。

* 如果组件可以接受最终一致性的数据，请使用事件携带状态传输消息。
* 如果消费者需要读取生产者的最后写入状态，就发出一个事件通知消息，并进行后续查询，以获取生产者的最新状态。

## 结论

本章介绍了事件驱动架构是设计限界上下文公开接口的一个固有方面。从中你学到了三种可用于跨边界上下文通信的事件类型：

*事件通知*

发生重要事情的通知，但需要消费者明确地向生产者查询其他信息。

*事件携带状态迁移*

一个基于消息的数据复制机制。每个事件都包含一个状态的快照，此快照可以用来维护生产者的数据本地缓存。

*领域事件*
描述生产者业务领域中事件的消息。

使用不恰当的事件类型会使基于 EDA 的系统脱轨，不经意间将其变成一个大泥球。为了选择正确的事件类型并进行集成，要评估限界上下文的一致性需求，并对暴露实现细节保持警惕。设计一套明确的公开事件和私有事件。最后，确保系统能够传递信息，即使在面对技术问题和停机的情况下。

## 练习
1.	以下哪些说法是正确的？<br>
A.	事件驱动架构定义了打算跨越组件边界的事件。<br>
B.	事件溯源定义了旨在保持在限界上下文边界内的事件。<br>
C.	事件驱动的架构和事件溯源是同一模式的不同术语。<br>
D.	A 和 B 是正确的。<br>

2.	哪种类型的事件最适合传达状态变化？<br>
A.	事件通知。<br>
B.	事件携带状态迁移。<br>
C.	领域事件。<br>
D.	所有的事件类型都同样适用于传达状态的变化。<br>

3.	哪种限界上下文集成模式需要明确定义公开事件？<br>
A.	开放主机服务。<br>
B.	防腐层。<br>
C.	共享内核。<br>
D.	遵奉者。<br>

4.	服务 S1 和 S2 是异步集成的。 S1 必须进行数据通信，S2 需要能够读取 S1 中最后写入的数据。哪种类型的事件适合这种集成场景？<br>
A.	S2 应该发布事件携带状态转移事件。<br>
B.	S2 应该发布公开事件通知，通知 S1 发出同步请求以获取最新信息。<br>
C.	S2 应该发布领域事件。<br>
D.	A 和 B。<br>


[^1]: Hohpe, G., & Woolf, B. (2003)。企业集成模式：设计、构建和部署消息传递解决方案。波士顿：Addison-Wesley。
[^2]: Fowler, M. (n.d.). 你说的 "事件驱动" 是什么意思？2021 年 8 月 12 日，从 Martin Fowler（博客）检索。
[^3]: Grove, A. S. (1998)。只有偏执狂才能生存。伦敦：HarperCollins Business。