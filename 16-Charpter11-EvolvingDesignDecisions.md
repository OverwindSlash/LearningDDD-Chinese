## 第 11 章
# 演化设计决策

在我们生活的现代、快节奏的世界中，公司无法承受昏昏欲睡的状态。为了跟上竞争的步伐，他们必须不断地改变、发展，甚至随着时间的推移重新塑造自己。我们在设计系统时不能忽视这个事实，特别是如果我们打算设计出能很好地适应其业务领域要求的软件。当变更没有得到适当的管理时，即使是最复杂和周到的设计最终也会成为维护和演化的噩梦。本章讨论了软件项目环境的变化会如何影响设计决策，以及如何相应地演化设计。我们将研究四个最常见的变化载体：业务领域、组织结构、领域知识和增长。

## 领域中的变化

在第 2 章中，你已经了解了三种类型的业务子域，以及它们之间的区别。

*核心子域*

公司为获得竞争优势而开展的与竞争对手不同的活动

*支撑子域*

公司在做的事情与竞争对手不同，但并不提供竞争优势

*通用子域*

所有公司都以同样的方式去做的事情

在前几章中，你看到了子域的类型会影响战略和战术设计决策。比如：

* 如何设计限界上下文的边界
* 如何编排上下文之间的集成
* 使用哪些设计模式来适应业务逻辑的复杂性

为了设计由业务领域需求驱动的软件，确定业务子领域和它们的类型至关重要。然而，这并不是故事的全部。同样重要的是，要对子域的演变保持警惕。随着一个组织的成长和发展，它的一些子域从一种类型演变成另一种类型是很正常的。让我们看一下这种变化的一些例子。

### 核心子域转变为通用子域

想象一下，一家名为 BuyIT 的在线零售公司一直在实施自己的订单交付解决方案。它开发了一种创新的算法来优化其快递员的送货路线，因此能够比其竞争对手收取更低的送货费用。

有一天，另一家公司 -- DeliverIT -- 颠覆了快递业。它声称自己已经解决了 "旅行推销员" 问题，并提供路径优化服务。DeliverIT 的优化不仅更先进，而且其价格只是 BuyIT 执行相同任务的一小部分。

从 BuyIT 的角度来看，一旦 DeliverIT 的解决方案成为现成的产品，其核心子域就变成了一个通用子域。结果，BuyIT 的所有竞争对手都可以使用更佳的解决方案。如果没有大规模的研发投资，BuyIT 就不能再在路径优化子域获得竞争优势。以前被认为是 BuyIT 竞争优势的东西，现在已经成为所有竞争对手都可以获得的商品。

### 通用子域转变为核心子域

自成立以来，BuyIT 一直使用一个现成的解决方案来管理其库存。然而，其商业智能报告不断显示出其对客户需求预测的不准确。因此，BuyIT 未能补充最受欢迎产品的库存，并且在不受欢迎的产品上浪费了库存空间。在评估了几个备选的库存管理解决方案后，BuyIT 的管理团队做出了投资设计并建立一个内部系统的战略决定。这个内部解决方案将考虑到 BuyIT 销售产品的复杂性，并对客户的需求做出更好的预测。

BuyIT 决定用自己的实现方案取代现成的解决方案，将库存管理从一个通用子领域变成了一个核心子领域：成功实施该功能将为 BuyIT 提供相对于其竞争对手的额外竞争优势 -- 竞争对手将继续 "困在" 通用解决方案中，无法使用 BuyIT 发明和开发的先进需求预测算法。

亚马逊就是将通用子域转变为核心子域的真实教科书式的案例。与所有服务提供商一样，亚马逊需要一个基础设施来运行其服务。该公司能 "重塑" 其管理物理基础设施的方式，后来甚至将其转变为一项有利可图的业务：Amazon Web Services。

### 支撑子域转变为通用子域

BuyIT 的市场部实施了一个系统来管理与之合作的供应商和他们的合同。这个系统没有什么特别或复杂的地方 -- 它只是一些输入数据的 CRUD 用户界面。换句话说，它是一个典型的支撑子域。

然而，在 BuyIT 开始实施内部解决方案的几年后，一个开源的合同管理解决方案出现了。这个开源项目实现了与现有解决方案相同的功能，并且还有更多的高级功能，如 OCR 和全文搜索。这些额外的功能在 BuyIT 被积压了很久，但由于其业务影响不大，从未被优先考虑。因此，该公司决定放弃内部解决方案，而选择整合开源解决方案。这样一来，文档管理子域就从一个支撑子域变成了一个通用子域。

### 支撑子域转变为核心子域

支撑子域也可以变成核心子域 -- 例如，如果公司找到一种方法来优化支撑逻辑，从而降低成本或产生额外利润。

这种转变的典型症状是支撑子域的业务逻辑越来越复杂。根据定义，支撑子域应该是简单的，主要类似于 CRUD 接口或 ETL 流程。然而，如果业务逻辑随着时间的推移变得越来越复杂，那么额外的复杂性应该是有其原因的。如果它不影响公司的利润，为什么会变得更加复杂？这可以归结为偶然的商业复杂性。另一方面，如果它增强了公司的盈利能力，这就是一个支撑子域成为核心子域的标志。

### 核心子域转变为支撑子域

随着时间的推移，一个核心子域可能成为一个支撑子域。这发生在子域的复杂性不合理的时候。换句话说，它不赚钱。在这种情况下，组织可能会决定削减不相干的复杂性，留下支撑实现其他子域所需的最小逻辑。

### 通用子域转变为支撑子域

最后，与核心子域的原因相同，通用子域可以变成一个支撑子域。回到 BuyIT 的文档管理系统的例子，假设该公司已经决定，整合开源解决方案的复杂性并不能证明它的好处，于是又回到了内部系统。结果，通用子域变成了一个支撑子域。

我们刚刚讨论的子域变化如图 11-1 所示。

<img src=images/figure11-1.png />
图 11-1. 子域类型变化因素 <br><br>

## 战略设计关注点

一个子域类型的改变会直接影响到它的限界上下文，因此也影响到相应的战略设计决策。正如你在第 4 章中所学到的，不同的限界上下文整合模式适合不同的子域类型。核心子域必须通过使用防腐层来保护它们的模型，必须通过使用发布的语言（OHS）来保护消费者免受模型实现频繁变化的影响。

另一个受这种变化影响的集成模式是另谋他路模式。正如你前面看到的，团队可以使用这种模式来实现支撑和通用子域。但如果子域转变为核心子域，由多个团队重复其功能就不再能被接受。因此，各团队别无选择，只能整合他们的实现。在这种情况下，客户-供应商模式的关系将是最有意义的，因为核心子域将只由一个团队实现。

从战略实施的角度来看，核心子域和支撑子域在实现方式上有所不同。支撑子域可以外包或作为新员工的 "培训课题"。核心子域必须在内部实现，并尽可能地接近领域知识的来源。因此，当一个支撑子域变成核心子域时，它的实现应该在内部进行。同样的逻辑反过来也适用。如果一个核心子域变成了支撑子域，就有可能把实现工作外包出去，让内部的研发团队专注于核心子域。

## 战术设计关注点

子域类型变化的主要指标是现有的技术设计无法支持当前的业务需求。

让我们回到支撑子域转为核心子域的例子。支撑子域是用相对简单的设计模式来实现业务逻辑建模的：即事务脚本或活动记录模式。正如你在第 5 章中看到的，这些模式并不适合涉及复杂规则和不变量的业务逻辑。

如果随着时间的推移，复杂的规则和不变量被添加到业务逻辑中，代码库也会变得越来越繁杂。增加新的功能会很痛苦，因为设计不支持新的复杂度。这种 "痛苦" 是一个重要的信号。可以把它作为重新评估业务领域和设计选择的呼声。

实现策略需要改变，这没什么好怕的。这很正常。我们无法预知一个企业在未来的道路上会如何发展。我们也不能对所有类型的子域应用最精细的设计模式；那将是浪费且低效的。我们必须选择最合适的设计，并在需要时对其进行演进。

如果可以有意识地决定如何对业务逻辑进行建模，并且你知道所有可能的设计选择和它们之间的区别，那么从一种设计模式迁移到另一种设计模式并不那么麻烦。以下小节重点介绍了几个示例。

### 从事务脚本到活动记录

事务脚本和活动记录模式在它们的核心中都基于相同的原则：业务逻辑被实现为过程脚本。它们之间的区别在于数据结构是如何建模的：活动记录模式引入了数据结构，以封装将它们映射到存储机制的复杂性。

因此，当在事务脚本中处理数据变得具有挑战性时，将其重构为活动记录模式。寻找复杂的数据结构并将其封装在活动记录对象中。不要直接访问数据库，而是使用活动记录来抽象其模型和结构。

### 从活动记录到领域模型

如果操作活动记录的业务逻辑变得复杂，而且你注意到越来越多的不一致和重复的情况，那么就应该把实现重构为领域模型模式。

从识别值对象开始。哪些数据结构可以被建模为不可变的对象？寻找相关的业务逻辑，并使其也成为值对象的一部分。

接下来，分析数据结构，寻找事务性的边界。为了确保所有的状态修改逻辑都是显式的，需要将所有活动记录的 Setter 都改成私有的，这样它们就只能从活动记录内部被修改。很明显，预计编译会失败；然而，编译错误会使状态修改逻辑的位置变得清晰。把它重构到活动记录的边界中。比如说。

```cs
public class Player
{
    public Guid Id { get; set; }
    public int Points { get; set; }
}

public class ApplyBonus
{
    // ...

    public void Execute(Guid playerId, byte percentage)
    {
        var player = _repository.Load(playerId);
        player.Points *= 1 + percentage/100.0;
        _repository.Save(player);
    }
}
```

在下面的代码中，你可以看到实现转换的第一步。这段代码还不能编译，但这些错误会让人清楚地看到外部组件在哪里控制对象的状态。

```cs
public class Player
{
    public Guid Id { get; private set; }
    public int Points { get; private set; }
}

public class ApplyBonus
{
    // ...

    public void Execute(Guid playerId, byte percentage)
    {
        var player = _repository.Load(playerId);
        player.Points *= 1 + percentage/100.0;
        _repository.Save(player);
    }
}
```

在下一次迭代中，我们可以把这个逻辑移到活动记录的边界内。

```cs
public class Player
{
    public Guid Id { get; private set; }
    public int Points { get; private set; }

    public void ApplyBonus(int percentage)
    {
        this.Points *= 1 + percentage/100.0;
    }
}

public class ApplyBonus
{
    // ...

    public void Execute(Guid playerId, int percentage)
    {
        var player = _repository.Load(playerId);
        player.ApplyBonus(percentage);
        _repository.Save(player);
    }
}
```

当所有修改状态的业务逻辑都被移到相应对象的边界内时，验证一下需要什么样的层次结构来确保对于业务规则和不变性的强一致性检查。这些是聚合的良好候选者。牢记我们在第 6 章中讨论的聚合设计原则，寻找最小的事务边界，也就是你需要保证强一致性的最小的数据量。沿着这些边界分解层次结构。确保外部聚合只能通过它们的 ID 来引用。

最后，对于每个聚合，确定它的聚合根，或其公共接口的入口点。使聚合中所有其他内部对象的方法成为私有的，并且只能从聚合内部调用。

### 从领域模型到事件溯源领域模型

一旦你有了正确设计了聚合边界的领域模型，你就可以把它过渡到事件溯源模型。与其直接修改聚合的数据，不如对代表聚合生命周期的领域事件进行建模。

将领域模型重构为事件溯源领域模型，最具挑战性的是现有聚合的历史：将 "无时间的" 状态迁移到基于事件的模型中。由于代表所有过去状态变化的细粒度数据已不存在，你必须尽力生成过去的事件或建立迁移事件模型。

### 生成过往状态迁移

这种方法需要为每个聚合生成一个近似的事件流，以便事件流可以被投影到与原始实现相同的状态表征中。考虑一下你在第 7 章看到的例子，如表 11-1 所示。

表 11-1. 基于状态的聚合数据表示法

|  lead-id |  first-name  |  last-name  |  phone-number  |  status  |  last-contacted-on  |  order-placed-on  |  converted-on  |  followup-on  |
|  ----  |  ----  |  ----  |  ----  |  ----  |  ----  |  ----  |  ----  |  ----  |
|  12  |  Shauna  |  Mercia  |  555-4753  |  converted  |  2020-05-27T 12:02:12.51Z  |  2020-05-27T 12:02:12.51Z  |  2020-05-27T 12:02:12.51Z  |  null  |

我们可以从业务逻辑的角度假设，聚合的实例已经被初始化；然后联系了这个人，下了一个订单，最后，由于状态是 "已转换"，所以订单的付款也已经被确认。下面这组事件可以代表所有这些假设。

```json
[
    {
        "lead-id": 12,
        "event-id": 0,
        "event-type": "lead-initialized",
        "first-name": "Shauna",
        "last-name": "Mercia",
        "phone-number": "555-4753"
    },
    {
        "lead-id": 12,
        "event-id": 1,
        "event-type": "contacted",
        "timestamp": "2020-05-27T12:02:12.51Z"
    },
    {
        "lead-id": 12,
        "event-id": 2,
        "event-type": "order-submitted",
        "payment-deadline": "2020-05-30T12:02:12.51Z",
        "timestamp": "2020-05-27T12:02:12.51Z"
    },
    {
        "lead-id": 12,
        "event-id": 3,
        "event-type": "payment-confirmed",
        "status": "converted",
        "timestamp": "2020-05-27T12:38:44.12Z"
    }
]
```

当这些事件被逐一应用时，它们可以被投影到与原始系统中完全相同的状态表征。通过投影状态并与原始数据进行比较，可以很容易地测试 "恢复" 事件。

然而，必须牢记这种方法的缺点。使用事件溯源的目的是要有一个可靠的、强一致的聚合领域事件的历史。当使用这种方法时，不可能恢复状态转换的完整历史。在前面的例子中，我们不知道销售人员联系了这个人多少次，因此，我们错过了不知道多少个 "已联系" 事件。

### 建模迁移事件

另一种方法是承认缺乏对过去事件的了解，并明确地将其建模为单一事件。与其试图手动恢复可能导致当前状态的事件，不如定义单一的迁移事件，用它来初始化现有聚合实例的事件流。

```json
{
    "lead-id": 12,
    "event-id": 0,
    "event-type": "migrated-from-legacy",
    "first-name": "Shauna",
    "last-name": "Mercia",
    "phone-number": "555-4753",
    "status": "converted",
    "last-contacted-on": "2020-05-27T12:02:12.51Z",
    "order-placed-on": "2020-05-27T12:02:12.51Z",
    "converted-on": "2020-05-27T12:38:44.12Z",
    "followup-on": null
}
```

这种方法的优点是，它使过去数据的缺乏变得明确。在任何阶段，人们都不能错误地认为事件流捕获了聚合实例生命周期中发生的所有领域事件。其缺点是，遗留系统的痕迹将永远保留在事件存储中。例如，如果你正在使用 CQRS 模式（并且你很可能会使用事件溯源领域模型），则投影必须始终考虑迁移事件。

## 组织变革

另一种可以影响系统设计的变化是组织本身的变化。第 4 章研究了整合限界上下文的不同模式：合作关系、共享内核、遵奉者、防腐层、开放主机服务和另谋他路。组织结构的变化会影响到团队的沟通和协作水平，从而影响到限界上下文的整合方式。

如图 11-2 所示，研发中心不断扩大就是这种变化的一个简单例子。由于限界上下文只能由一个团队实现，因此添加新的开发团队可能会导致现有的更宽广的限界上下文边界分裂成更小的边界，以便每个团队都可以在自己的限界上下文上工作。

<img src=images/figure11-2.png />
图 11-2. 拆分宽广的限界上下文以适应不断增长的工程团队 <br><br>

此外，组织的研发中心通常位于不同的地理位置。当现有限界上下文的工作转移到另一个位置时，可能会对团队的协作产生负面影响。因此，限界上下文的集成模式必须相应地演化，如以下场景所述。

### 从合作关系到客户-供应商关系

合作关系模式假定团队之间有很紧密的沟通和协作。随着时间的推移，这种情况可能不复存在；例如，当其中一个限界上下文的工作被转移到一个遥远的研发中心。这样的变化会对团队的沟通产生负面影响，因此，从合作关系模式转向客户-供应商关系模式可能是合理的。

### 从客户-供应商关系到另谋他路关系

不幸的是，团队出现严重的沟通问题并不罕见。这些问题可能是由地理距离或组织政治造成的。随着时间的推移，这样的团队可能会经历越来越多的整合问题。在某些时候，复制功能而不是不断地追随对方，可能会变得更具成本效益。

## 领域知识

正如你所记得的那样，领域驱动设计的核心原则是，领域知识对于设计一个成功的软件系统是至关重要的。获取领域知识是软件工程中最具挑战的方面之一，特别是对于核心子域。一个核心子域的逻辑不仅复杂，而且预计会经常变化。此外，建模是一个持续的过程。随着获得更多的业务领域知识，模型必须持续改进。

很多时候，业务领域的复杂性是隐晦的。最初，一切似乎都简单明了。最初的简单性通常具有欺骗性，它很快就会演变成复杂性。随着更多功能的添加，越来越多的极端情况、不变量和规则被发现。这种洞见通常具有破坏性，需要从头开始构建模型，包括限界上下文、聚合和其他实现细节的边界。

从战略设计的角度来看，根据领域知识的水平来设计限界上下文的边界是一个有用的启发式方法。将一个系统分解成限界上下文，但随着时间的推移，这些上下文很可能被证明是不正确的，这种做法的代价会很高。因此，当领域逻辑不明确且经常变化时，设计边界较宽的上下文是有意义的。然后，随着时间的推移，领域知识被发现，业务逻辑的变化趋于稳定，这些宽泛的限界上下文可以被分解成边界较窄的上下文，或者说 *微服务*。我们将在第 14 章中更详细地讨论限界上下文和微服务之间的相互作用。

当新的领域知识被发现时，应该利用它来演化设计，使其更有弹性。不幸的是，领域知识的变化并不总是正向的：领域知识可能会丢失。随着时间的推移，文档往往变得陈旧，从事原始设计的人离开了公司，新的功能以临时的方式被添加，直到有一天，遗留系统的代码库变成了宁人质疑的形态。主动防止领域知识的这种退化是至关重要的。恢复领域知识的一个有效工具是事件风暴（EventStorming）研讨会，这是下一章的主题。

## 增长

增长是健康系统的标志。当不断添加新功能时，这表明系统是成功的：它为用户带来了价值，并被扩展以进一步满足用户的需求并跟上竞争产品的步伐。但增长也有阴暗面。随着软件项目的增长，它的代码库可能会变成一个大泥球：

> 大泥球是一个结构随意、不断蔓延、邋遢、到处是补丁、意大利面条式代码的丛林。这些系统显示出明显的不受控制的生长迹象，以及反复的、权宜之计的修补。<br>
> —Brian Foote and Joseph Yoder [^1]

无节制的增长导致了大泥球的出现，这是因为在没有重新评估其设计决策的情况下扩展了软件系统的功能。增长炸开了组件的边界，越来越多地扩展了它们的功能。检查增长对设计决策的影响是至关重要的，特别是由于许多领域驱动的设计工具都是关于设置边界的：业务构件（子域）、模型（限界上下文）、不变性（值对象）或一致性（聚合）。

处理由增长驱动的复杂性的指导原则是识别和消除意外的复杂性：也就是由过时的设计决策引起的复杂性。基本的复杂性，或业务领域固有的复杂性，应该使用领域驱动的设计工具和实践来管理。

当我们在前几章讨论 DDD 时，我们遵循的流程是首先分析业务领域及其战略组成部分，设计业务领域的相关模型，然后在代码中设计和实现这些模型。让我们按照同样的脚本来处理增长驱动的复杂性。

### 子域

正如我们在第 1 章中所讨论的，子域的边界很难识别，因此，我们必须努力寻找有用的边界，而不是追求完美的边界。也就是说，子域应该允许我们识别具有不同业务价值的组件并使用适当的工具来设计和实施解决方案。

随着业务领域的增长，子域的边界会变得更加模糊，这使得识别跨越多个更细粒度子域的情况变得更加困难。因此，重要的是重新审视已识别的子域并遵循连贯用例（处理同一组数据的用例集）的启发式方法，以尝试确定在何处拆分子域（见图 11-3）。

<img src=images/figure11-3.png />
图 11-3. 优化子域的边界以适应增长 <br><br>

如果你能够确定不同类型的细粒度子域，这是一种重要的洞察力，它将使你能够管理业务领域的基本复杂性。关于子域及其类型的信息越精确，你在为每个子域选择技术解决方案时就会越有效。

### 限界上下文

在第 3 章中，你了解到限界上下文模式允许我们使用业务领域的不同模型。与其建立一个 “样样都会，样样不精通” 的模型，我们不如建立多个模型，每个模型都专注于解决一个特定的问题。

随着项目的发展和壮大，限界上下文失去聚焦并积累了与不同问题相关的业务逻辑是很常见的。这就是意料之外的复杂性。就像子域一样，不时地重新审视限界上下文的边界是很关键的。始终寻找机会来简化模型，提取那些专注于解决特定问题的限界上下文。

增长也会使现有的隐性设计问题显性化。例如，你可能会注意到，随着时间的推移，一些限界上下文变得越来越 "健谈"，不调用另一个限界上下文就无法完成任何操作。这可能是一个无效模型的强烈信号，应该通过重新设计限界上下文的边界来解决，以增加它们的自治性。

### 聚合

当我们在第 6 章讨论领域模型模式时，我们使用了以下指导原则来设计聚合的边界。

> 经验法则是保持尽可能小的聚合，只包括业务领域要求处于强一致性状态的对象。

随着系统业务需求的增长，可以 "方便" 地在现有的聚合中分配新的功能，而无需重新审视保持聚合最小化的原则。如果聚合增长到包含了不需要与其所有业务逻辑保持强一致性的数据时，就必须得消除这种意外的复杂性了。

将业务功能提取到一个专门的聚合中，不仅可以简化原有聚合，而且还有可能会简化它所属的限界上下文。通常，这样的重构会揭示额外的隐藏模型，一旦模型被明确，它就应该被提取到不同的限界上下文中。

## 结论

正如赫拉克利特（Heraclitus）的名言，生活中唯一不变的是变化本身。企业也不例外。为了保持竞争力，公司不断努力发展和重塑自己。这些变化应被视为设计过程的一等要素。

随着业务领域的发展，其子领域的变化必须在系统的设计中被识别并采取相应行动。确保你过去的设计决策与业务领域及其子域的当前状态能保持一致。并在需要时，演进你的设计以更好地匹配当前的业务战略和需求。

同样重要的是，要认识到组织结构的变化会影响团队之间的沟通和合作，以及他们的限界上下文的整合方式。对业务领域的学习是一个持续的过程。随着时间的推移，更多的领域知识被发现，它必须被利用来演进战略和战术设计决策。

最后，虽然软件增长是一种可预期的变化类型，但是当它没有得到正确的管理时，仍可能会对系统设计和结构产生灾难性的影响。

* 当一个子域的功能被扩展时，试着确定更细的子域边界，这将使你能够做出更好的设计决策。
* 不要让限界上下文成为 "万能的"。确保限界上下文所包含的模型专注于解决具体问题。
* 确保你的聚合的边界尽可能的小。使用强一致性数据的启发式方法来检查将业务逻辑提取到新聚合中的可能性。

在这个问题上，我的最后一句话是：不断检查不同的边界，看是否有增长驱动的复杂性的迹象。采取行动来消除意料之外的复杂性，并使用领域驱动的设计工具来管理业务领域的基本复杂性。

## 练习
1. 组织的成长往往会引起限界上下文整合的哪种变化？<br>
A. 从合作关系变为客户-供应商关系（遵奉者、防腐层或开放主机服务） <br>
B. 从防腐层到开放主机服务 <br>
C. 从遵奉者到共享内核 <br>
D. 从开放主机服务到共享内核 <br>

2.	假设限界上下文的整合关系从遵奉者转变为另谋他路。根据这一变化，你能推断出什么信息？<br>
A. 开发团队在合作上很费劲。 <br>
B. 重复的功能要么是支撑子域要么是通用子域。 <br>
C. 重复的功能是核心子域 <br>
D. A 和 B <br>
E. A 和 C <br>

3. 支撑子域变成核心子域的表现是什么？<br>
A.	改进现有模型和实现新需求变得更加容易。<br>
B.	改进现有模型变得很痛苦。<br>
C.	子域以更高的频率变化。<br>
D.	B 和 C <br>
E.	以上都不是。<br>

4. 发现新的商机会带来什么变化？<br>
A.	支撑子域变成核心子域。<br>
B.	支撑子域变成通用子域。<br>
C.	通用子域变成核心子域。<br>
D.	通用子域变成支撑子域。<br>
E.	A 和 B <br>
F.	A 和 C <br>

5. 商业战略中的什么变化可以将 WolfDesk（序言中介绍的虚构公司）的一个通用子域变成核心子域？



[^1]: Brian Foote 和 Joseph Yoder。大泥球。第四届程序模式语言会议 (PLoP ’97/EuroPLoP ’97)，伊利诺伊州蒙蒂塞洛，1997 年 9 月。